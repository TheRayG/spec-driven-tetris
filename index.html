<!--
  MIT License

  Copyright (c) 2026 TheRayG

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Press Start 2P', cursive;
  background: #222222;
  color: #FFFFFF;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
  padding: 20px;
}
#game-layout {
  display: flex;
  gap: 40px;
  justify-content: center;
  align-items: flex-start;
}
.side-panel {
  min-width: 180px;
  max-width: 220px;
}
.side-panel h3, .ai-panel h3 {
  color: #00FFFF;
  font-size: 10px;
  margin-bottom: 10px;
  text-transform: uppercase;
}
.ai-panel {
  min-width: 180px;
  max-width: 240px;
}
.panel-section {
  background: rgba(0, 255, 255, 0.05);
  border: 1px solid rgba(0, 255, 255, 0.2);
  border-radius: 4px;
  padding: 10px;
  margin-bottom: 15px;
}
.controls-list {
  font-size: 7px;
  line-height: 2.2;
  color: #ccc;
}
.controls-list span {
  color: #00FFFF;
}
.stat-row {
  display: flex;
  justify-content: space-between;
  font-size: 8px;
  margin-bottom: 8px;
}
.stat-label { color: #aaa; }
.stat-value { color: #00FF00; }
#game-container {
  display: flex;
  gap: 20px;
  align-items: flex-start;
}
#board-wrapper {
  position: relative;
  border: 3px solid #00FFFF;
  padding: 4px;
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}
#game-board {
  display: grid;
  grid-template-columns: repeat(10, 25px);
  grid-template-rows: repeat(20, 25px);
  width: 250px;
  height: 500px;
}
.cell {
  width: 25px;
  height: 25px;
  border: 1px solid rgba(0, 0, 0, 0.1);
}
.cell.filled {
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
}
.cell.ghost {
  background: transparent !important;
  border: 1px dashed white;
  opacity: 0.3;
  box-shadow: none;
}
.preview-container { text-align: center; }
.preview-container h4 {
  color: #00FFFF;
  font-size: 8px;
  margin-bottom: 5px;
}
.preview-grid {
  display: grid;
  grid-template-columns: repeat(4, 20px);
  grid-template-rows: repeat(4, 20px);
  width: 80px;
  height: 80px;
  border: 1px solid rgba(0, 255, 255, 0.3);
  margin-bottom: 15px;
}
.preview-cell {
  width: 20px;
  height: 20px;
  border: 0.5px solid rgba(255, 255, 255, 0.05);
}
.preview-cell.filled {
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
}
/* Overlay screens */
.overlay {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10;
}
.overlay h1 {
  color: #00FFFF;
  font-size: 24px;
  margin-bottom: 15px;
  text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}
.overlay h2 {
  color: #00FFFF;
  font-size: 16px;
  margin-bottom: 10px;
}
.overlay p {
  font-size: 8px;
  margin-bottom: 10px;
  color: #ccc;
}
.overlay .final-stats {
  font-size: 7px;
  margin-bottom: 5px;
  color: #aaa;
}
.btn {
  font-family: 'Press Start 2P', cursive;
  background: #00FF00;
  color: #000;
  border: none;
  padding: 10px 20px;
  font-size: 10px;
  cursor: pointer;
  margin-top: 10px;
  transition: background 200ms;
}
.btn:hover { background: #00CC00; }
.btn-small {
  font-family: 'Press Start 2P', cursive;
  background: #666;
  color: #fff;
  border: none;
  padding: 5px 10px;
  font-size: 7px;
  cursor: pointer;
  transition: background 200ms;
}
.btn-small:hover { background: #888; }
/* AI Panel */
.ai-heading {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.ai-badge {
  font-size: 7px;
  padding: 2px 6px;
  border-radius: 3px;
}
.ai-on { color: #00FF00; }
.ai-off { color: #FF4444; }
.slider-group {
  margin-bottom: 10px;
}
.slider-group label {
  display: block;
  font-size: 7px;
  color: #aaa;
  margin-bottom: 3px;
}
.slider-group input[type="range"] {
  width: 100%;
  margin-bottom: 2px;
}
.slider-value {
  font-size: 7px;
  color: #00FF00;
  text-align: right;
}
.speed-select {
  font-family: 'Press Start 2P', cursive;
  font-size: 7px;
  background: #333;
  color: #fff;
  border: 1px solid #00FFFF;
  padding: 4px;
  width: 100%;
  margin-bottom: 10px;
}
.hs-section {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid rgba(0, 255, 255, 0.2);
}
/* Responsive */
@media (max-width: 799px) {
  #game-layout {
    flex-direction: column;
    align-items: center;
    gap: 20px;
  }
  #game-container { order: -1; }
  .side-panel, .ai-panel {
    max-width: 100%;
    min-width: auto;
    width: 100%;
  }
}
</style>
</head>
<body>
<div id="game-layout">
  <!-- Left Panel: Controls & Stats -->
  <div class="side-panel">
    <div class="panel-section">
      <h3>Controls</h3>
      <div class="controls-list">
        <span>←/→</span> Move<br>
        <span>↑/X</span> Rotate<br>
        <span>↓</span> Soft Drop<br>
        <span>Space</span> Hard Drop<br>
        <span>C/Shift</span> Hold<br>
        <span>P/Esc</span> Pause<br>
        <span>R</span> Restart<br>
        <span>G</span> Ghost Toggle<br>
        <span>A</span> AI Toggle
      </div>
    </div>
    <div class="panel-section">
      <h3>Statistics</h3>
      <div class="stat-row"><span class="stat-label">Score</span><span class="stat-value" id="stat-score">0</span></div>
      <div class="stat-row"><span class="stat-label">Level</span><span class="stat-value" id="stat-level">1</span></div>
      <div class="stat-row"><span class="stat-label">Lines</span><span class="stat-value" id="stat-lines">0</span></div>
      <div class="stat-row"><span class="stat-label">Speed</span><span class="stat-value" id="stat-speed">1000ms</span></div>
      <div class="stat-row"><span class="stat-label">AI Score</span><span class="stat-value" id="stat-ai-score">N/A</span></div>
      <div class="hs-section">
        <h3>High Score</h3>
        <div class="stat-row"><span class="stat-label">Score</span><span class="stat-value" id="hs-score">0</span></div>
        <div class="stat-row"><span class="stat-label">Lines</span><span class="stat-value" id="hs-lines">0</span></div>
        <div class="stat-row"><span class="stat-label">Level</span><span class="stat-value" id="hs-level">1</span></div>
        <button class="btn-small" id="reset-hs-btn">Reset High Score</button>
      </div>
    </div>
  </div>

  <!-- Center: Game Board + Previews -->
  <div id="game-container">
    <div id="board-wrapper">
      <div id="game-board"></div>
      <!-- Title Screen -->
      <div class="overlay" id="title-screen">
        <h1>TETRIS</h1>
        <p>Press Start to Play</p>
        <button class="btn" id="start-btn">Start Game</button>
      </div>
      <!-- Pause Screen -->
      <div class="overlay" id="pause-screen" style="display:none;">
        <h2>Paused</h2>
        <button class="btn" id="resume-btn">Resume</button>
      </div>
      <!-- Game Over Screen -->
      <div class="overlay" id="gameover-screen" style="display:none;">
        <h2>Game Over!</h2>
        <p class="final-stats" id="final-score"></p>
        <p class="final-stats" id="final-lines"></p>
        <p class="final-stats" id="final-level"></p>
        <button class="btn" id="restart-btn">Restart Game</button>
      </div>
    </div>
    <div>
      <div class="preview-container">
        <h4>Next</h4>
        <div class="preview-grid" id="next-preview"></div>
      </div>
      <div class="preview-container">
        <h4>Hold</h4>
        <div class="preview-grid" id="hold-preview"></div>
      </div>
    </div>
  </div>

  <!-- Right Panel: AI Tuning -->
  <div class="ai-panel">
    <div class="panel-section">
      <div class="ai-heading">
        <h3>AI Tuning</h3>
        <span class="ai-badge ai-off" id="ai-badge">AI OFF</span>
      </div>
      <div style="margin-top:10px;">
        <label style="font-size:7px;color:#aaa;">Autoplay Delay</label>
        <select class="speed-select" id="autoplay-delay">
          <option value="20">20ms (Very Fast)</option>
          <option value="100">100ms (Fast)</option>
          <option value="200" selected>200ms (Normal)</option>
          <option value="500">500ms (Slow)</option>
          <option value="1000">1000ms (Very Slow)</option>
        </select>
      </div>
      <div class="slider-group">
        <label>Lines Cleared: <span class="slider-value" id="w-lines-val">2.0</span></label>
        <input type="range" id="w-lines" min="0" max="2" step="0.1" value="2.0">
      </div>
      <div class="slider-group">
        <label>Holes Penalty: <span class="slider-value" id="w-holes-val">-2.0</span></label>
        <input type="range" id="w-holes" min="-2" max="0" step="0.1" value="-2.0">
      </div>
      <div class="slider-group">
        <label>Bumpiness: <span class="slider-value" id="w-bump-val">-1.0</span></label>
        <input type="range" id="w-bump" min="-1" max="0" step="0.1" value="-1.0">
      </div>
      <div class="slider-group">
        <label>Height: <span class="slider-value" id="w-height-val">-0.01</span></label>
        <input type="range" id="w-height" min="-0.1" max="0" step="0.01" value="-0.01">
      </div>
      <div class="slider-group">
        <label>Valley Depth: <span class="slider-value" id="w-valley-val">-1.0</span></label>
        <input type="range" id="w-valley" min="-1" max="0" step="0.1" value="-1.0">
      </div>
      <button class="btn-small" id="reset-weights-btn">Reset Defaults</button>
    </div>
  </div>
</div>

<script>
// ==================== CONSTANTS ====================
const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;
const BLOCK_SIZE = 25;
const INITIAL_FAST_DROP_COUNT = 3;

const TETROMINOS = [
  [[1,1,1,1],[0,0,0,0],[0,0,0,0],[0,0,0,0]], // I
  [[1,1],[1,1]],                                // O
  [[0,1,0],[1,1,1],[0,0,0]],                    // T
  [[0,1,1],[1,1,0],[0,0,0]],                    // S
  [[1,1,0],[0,1,1],[0,0,0]],                    // Z
  [[1,0,0],[1,1,1],[0,0,0]],                    // J
  [[0,0,1],[1,1,1],[0,0,0]]                     // L
];

const COLORS = ['cyan', 'yellow', 'purple', 'green', 'red', 'blue', 'orange'];

const DEFAULT_AI_WEIGHTS = {
  lines: 2.0,
  holes: -2.0,
  bumpiness: -1.0,
  height: -0.01,
  valley: -1.0
};

// ==================== GAME STATE ====================
let board = [];
let currentPiece = null;
let currentShape = null;
let currentType = 0;
let currentX = 0;
let currentY = 0;
let nextType = -1;
let holdType = -1;
let canHold = true;
let score = 0;
let level = 1;
let totalLines = 0;
let levelLines = 0;
let dropCounter = 0;
let gameActive = false;
let gamePaused = false;
let gameOver = false;
let ghostEnabled = true;
let autoplayEnabled = false;
let dropInterval = null;
let lockDelayTimer = null;
let autoplayTimers = [];
let aiWeights = { ...DEFAULT_AI_WEIGHTS };
let autoplayDelay = 200;
let lastAIScore = 'N/A';

// ==================== DOM ELEMENTS ====================
const boardEl = document.getElementById('game-board');
const nextPreviewEl = document.getElementById('next-preview');
const holdPreviewEl = document.getElementById('hold-preview');
const titleScreen = document.getElementById('title-screen');
const pauseScreen = document.getElementById('pause-screen');
const gameoverScreen = document.getElementById('gameover-screen');

// ==================== INITIALIZATION ====================
function initBoard() {
  board = [];
  for (let y = 0; y < BOARD_HEIGHT; y++) {
    board.push(new Array(BOARD_WIDTH).fill(0));
  }
}

function initBoardDOM() {
  boardEl.innerHTML = '';
  for (let y = 0; y < BOARD_HEIGHT; y++) {
    for (let x = 0; x < BOARD_WIDTH; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x;
      cell.dataset.y = y;
      boardEl.appendChild(cell);
    }
  }
}

function initPreviewDOM(el) {
  el.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    const cell = document.createElement('div');
    cell.className = 'preview-cell';
    el.appendChild(cell);
  }
}

// ==================== COLLISION DETECTION ====================
function checkCollision(shape, posX, posY) {
  for (let y = 0; y < shape.length; y++) {
    for (let x = 0; x < shape[y].length; x++) {
      if (!shape[y][x]) continue;
      const boardX = posX + x;
      const boardY = posY + y;
      // Check horizontal bounds
      if (boardX < 0 || boardX >= BOARD_WIDTH) return true;
      // Check bottom bound
      if (boardY >= BOARD_HEIGHT) return true;
      // Only check board cells within visible area
      if (boardY >= 0 && board[boardY][boardX] !== 0) return true;
    }
  }
  return false;
}

// ==================== PIECE OPERATIONS ====================
function getShape(type) {
  return TETROMINOS[type].map(row => [...row]);
}

function rotateMatrix(matrix) {
  const n = matrix.length;
  const rotated = [];
  for (let i = 0; i < n; i++) {
    rotated.push([]);
    for (let j = 0; j < n; j++) {
      rotated[i].push(matrix[n - 1 - j][i]);
    }
  }
  return rotated;
}

function spawnPiece() {
  if (nextType === -1) {
    currentType = Math.floor(Math.random() * 7);
  } else {
    currentType = nextType;
  }
  nextType = Math.floor(Math.random() * 7);
  currentShape = getShape(currentType);
  currentX = Math.floor(BOARD_WIDTH / 2) - Math.ceil(currentShape[0].length / 2);
  currentY = -currentShape.length;
  dropCounter = 0;
  updateNextPreview();
  if (autoplayEnabled) scheduleAutoplayMove();
  setDropInterval();
}

// ==================== DROP SPEED ====================
function getDropSpeed() {
  return Math.max(50, 1000 - (level - 1) * 25);
}

function getLinesPerLevel(lvl) {
  if (lvl < 10) return 10;
  if (lvl < 20) return 12;
  if (lvl < 30) return 14;
  if (lvl < 40) return 16;
  if (lvl < 50) return 18;
  return 20;
}

function setDropInterval() {
  if (dropInterval) clearInterval(dropInterval);
  const speed = (dropCounter < INITIAL_FAST_DROP_COUNT) ? 100 : getDropSpeed();
  dropInterval = setInterval(autoDown, speed);
}

// ==================== AUTOMATIC DESCENT ====================
function autoDown() {
  if (!gameActive || gamePaused || gameOver) return;
  if (!checkCollision(currentShape, currentX, currentY + 1)) {
    currentY++;
    if (lockDelayTimer) {
      clearTimeout(lockDelayTimer);
      lockDelayTimer = null;
    }
    dropCounter++;
    if (dropCounter === INITIAL_FAST_DROP_COUNT) {
      setDropInterval();
    }
    drawBoard();
  } else {
    // Start lock delay
    if (!lockDelayTimer) {
      lockDelayTimer = setTimeout(() => {
        lockDelayTimer = null;
        lockPiece();
      }, getDropSpeed());
    }
  }
}

// ==================== MOVEMENT ====================
function moveLeft() {
  if (!checkCollision(currentShape, currentX - 1, currentY)) {
    currentX--;
    drawBoard();
  }
}

function moveRight() {
  if (!checkCollision(currentShape, currentX + 1, currentY)) {
    currentX++;
    drawBoard();
  }
}


function rotateCW() {
  const rotated = rotateMatrix(currentShape);
  const kicks = [0, -1, 1, -2, 2];
  for (const kick of kicks) {
    const newX = currentX + kick;
    // Bounds check for all blocks
    let outOfBounds = false;
    for (let y = 0; y < rotated.length; y++) {
      for (let x = 0; x < rotated[y].length; x++) {
        if (rotated[y][x]) {
          const bx = newX + x;
          if (bx < 0 || bx >= BOARD_WIDTH) { outOfBounds = true; break; }
        }
      }
      if (outOfBounds) break;
    }
    if (outOfBounds) continue;
    if (!checkCollision(rotated, newX, currentY)) {
      currentShape = rotated;
      currentX = newX;
      drawBoard();
      return;
    }
  }
}

function softDrop() {
  if (!checkCollision(currentShape, currentX, currentY + 1)) {
    currentY++;
    score += 1;
    if (lockDelayTimer) {
      clearTimeout(lockDelayTimer);
      lockDelayTimer = null;
    }
    updateScoreDisplay();
    drawBoard();
  } else {
    score += 1;
    if (lockDelayTimer) {
      clearTimeout(lockDelayTimer);
      lockDelayTimer = null;
    }
    updateScoreDisplay();
    lockPiece();
  }
}

function hardDrop() {
  let cells = 0;
  while (!checkCollision(currentShape, currentX, currentY + 1)) {
    currentY++;
    cells++;
  }
  score += cells * 2;
  if (lockDelayTimer) {
    clearTimeout(lockDelayTimer);
    lockDelayTimer = null;
  }
  updateScoreDisplay();
  lockPiece();
}

// ==================== PIECE LOCKING ====================
function lockPiece() {
  // Copy piece to board
  for (let y = 0; y < currentShape.length; y++) {
    for (let x = 0; x < currentShape[y].length; x++) {
      if (currentShape[y][x]) {
        const boardY = currentY + y;
        const boardX = currentX + x;
        if (boardY < 0) {
          triggerGameOver();
          return;
        }
        if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
          board[boardY][boardX] = currentType + 1;
        }
      }
    }
  }
  clearLines();
  canHold = true;
  dropCounter = 0;
  spawnPiece();
}

// ==================== LINE CLEARING ====================
function clearLines() {
  let linesCleared = 0;
  for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
    if (board[y].every(cell => cell !== 0)) {
      board.splice(y, 1);
      board.unshift(new Array(BOARD_WIDTH).fill(0));
      linesCleared++;
      y++; // Re-check same row
    }
  }
  if (linesCleared > 0) {
    const lineScores = [0, 100, 300, 500, 800];
    score += lineScores[linesCleared] * level;
    totalLines += linesCleared;
    levelLines += linesCleared;
    // Check level up
    while (levelLines >= getLinesPerLevel(level)) {
      levelLines -= getLinesPerLevel(level);
      level++;
    }
    updateScoreDisplay();
    updateStats();
    drawBoard();
  }
}

// ==================== HOLD PIECE ====================
function holdPiece() {
  if (!canHold) return;
  canHold = false;
  if (lockDelayTimer) {
    clearTimeout(lockDelayTimer);
    lockDelayTimer = null;
  }
  const prevHold = holdType;
  holdType = currentType;
  if (prevHold === -1) {
    spawnPiece();
  } else {
    currentType = prevHold;
    currentShape = getShape(currentType);
    currentX = Math.floor(BOARD_WIDTH / 2) - Math.ceil(currentShape[0].length / 2);
    currentY = -currentShape.length;
    dropCounter = 0;
    if (autoplayEnabled) scheduleAutoplayMove();
    setDropInterval();
  }
  updateHoldPreview();
  drawBoard();
}

// ==================== GHOST PIECE ====================
function getGhostY() {
  let ghostY = currentY;
  while (!checkCollision(currentShape, currentX, ghostY + 1)) {
    ghostY++;
  }
  return ghostY;
}

// ==================== RENDERING ====================
function drawBoard() {
  const cells = boardEl.children;
  // Draw board state
  for (let y = 0; y < BOARD_HEIGHT; y++) {
    for (let x = 0; x < BOARD_WIDTH; x++) {
      const cell = cells[y * BOARD_WIDTH + x];
      cell.className = 'cell';
      cell.style.background = '';
      if (board[y][x] !== 0) {
        cell.className = 'cell filled';
        cell.style.background = COLORS[board[y][x] - 1];
      }
    }
  }
  if (!currentShape) return;
  // Draw ghost piece
  if (ghostEnabled) {
    const ghostY = getGhostY();
    if (ghostY !== currentY) {
      for (let y = 0; y < currentShape.length; y++) {
        for (let x = 0; x < currentShape[y].length; x++) {
          if (currentShape[y][x]) {
            const by = ghostY + y;
            const bx = currentX + x;
            if (by >= 0 && by < BOARD_HEIGHT && bx >= 0 && bx < BOARD_WIDTH) {
              const cell = cells[by * BOARD_WIDTH + bx];
              if (!cell.classList.contains('filled')) {
                cell.className = 'cell ghost';
              }
            }
          }
        }
      }
    }
  }
  // Draw current piece
  for (let y = 0; y < currentShape.length; y++) {
    for (let x = 0; x < currentShape[y].length; x++) {
      if (currentShape[y][x]) {
        const by = currentY + y;
        const bx = currentX + x;
        if (by >= 0 && by < BOARD_HEIGHT && bx >= 0 && bx < BOARD_WIDTH) {
          const cell = cells[by * BOARD_WIDTH + bx];
          cell.className = 'cell filled';
          cell.style.background = COLORS[currentType];
        }
      }
    }
  }
}

function updateNextPreview() {
  renderPreview(nextPreviewEl, nextType);
}

function updateHoldPreview() {
  renderPreview(holdPreviewEl, holdType);
}

function renderPreview(el, type) {
  const cells = el.children;
  for (let i = 0; i < 16; i++) {
    cells[i].className = 'preview-cell';
    cells[i].style.background = '';
  }
  if (type < 0) return;
  const shape = getShape(type);
  for (let y = 0; y < shape.length; y++) {
    for (let x = 0; x < shape[y].length; x++) {
      if (shape[y][x]) {
        const idx = y * 4 + x;
        if (idx < 16) {
          cells[idx].className = 'preview-cell filled';
          cells[idx].style.background = COLORS[type];
        }
      }
    }
  }
}

// ==================== SCORE & STATS ====================
function updateScoreDisplay() {
  document.getElementById('stat-score').textContent = score;
  // Check high score
  const hs = loadHighScore();
  if (score > hs.score) {
    saveHighScore({ score, lines: totalLines, level });
    displayHighScore();
  }
}

function updateStats() {
  document.getElementById('stat-score').textContent = score;
  document.getElementById('stat-level').textContent = level;
  document.getElementById('stat-lines').textContent = totalLines;
  document.getElementById('stat-speed').textContent = getDropSpeed() + 'ms';
  document.getElementById('stat-ai-score').textContent = autoplayEnabled ? lastAIScore : 'N/A';
}

function displayHighScore() {
  const hs = loadHighScore();
  document.getElementById('hs-score').textContent = hs.score;
  document.getElementById('hs-lines').textContent = hs.lines;
  document.getElementById('hs-level').textContent = hs.level;
}

// ==================== LOCAL STORAGE ====================
function loadHighScore() {
  try {
    const data = JSON.parse(localStorage.getItem('tetrisHighScore'));
    return {
      score: (data && typeof data.score === 'number') ? data.score : 0,
      lines: (data && typeof data.lines === 'number') ? data.lines : 0,
      level: (data && typeof data.level === 'number') ? data.level : 1
    };
  } catch (e) {
    console.error('Failed to load high score:', e);
    return { score: 0, lines: 0, level: 1 };
  }
}

function saveHighScore(hs) {
  try {
    localStorage.setItem('tetrisHighScore', JSON.stringify(hs));
  } catch (e) {
    console.error('Failed to save high score:', e);
  }
}

function loadAIWeights() {
  try {
    const data = JSON.parse(localStorage.getItem('tetrisAIWeights'));
    if (data) {
      aiWeights = { ...DEFAULT_AI_WEIGHTS, ...data };
    }
  } catch (e) {
    console.error('Failed to load AI weights:', e);
    aiWeights = { ...DEFAULT_AI_WEIGHTS };
  }
}

function saveAIWeights() {
  try {
    localStorage.setItem('tetrisAIWeights', JSON.stringify(aiWeights));
  } catch (e) {
    console.error('Failed to save AI weights:', e);
  }
}

// ==================== GAME STATE MANAGEMENT ====================
function startGame() {
  titleScreen.style.display = 'none';
  pauseScreen.style.display = 'none';
  gameoverScreen.style.display = 'none';
  initBoard();
  score = 0;
  level = 1;
  totalLines = 0;
  levelLines = 0;
  holdType = -1;
  canHold = true;
  nextType = -1;
  gameActive = true;
  gamePaused = false;
  gameOver = false;
  lastAIScore = 'N/A';
  updateStats();
  updateHoldPreview();
  spawnPiece();
  drawBoard();
}

function togglePause() {
  if (gameOver) return;
  if (!gameActive) return;
  if (gamePaused) {
    gamePaused = false;
    pauseScreen.style.display = 'none';
    setDropInterval();
  } else {
    gamePaused = true;
    pauseScreen.style.display = 'flex';
    if (dropInterval) { clearInterval(dropInterval); dropInterval = null; }
  }
}

function triggerGameOver() {
  gameOver = true;
  gameActive = false;
  if (dropInterval) { clearInterval(dropInterval); dropInterval = null; }
  if (lockDelayTimer) { clearTimeout(lockDelayTimer); lockDelayTimer = null; }
  clearAutoplayTimers();
  // Update high score one final time
  const hs = loadHighScore();
  if (score > hs.score) {
    saveHighScore({ score, lines: totalLines, level });
    displayHighScore();
  }
  document.getElementById('final-score').textContent = 'Score: ' + score;
  document.getElementById('final-lines').textContent = 'Lines: ' + totalLines;
  document.getElementById('final-level').textContent = 'Level: ' + level;
  gameoverScreen.style.display = 'flex';
  drawBoard();
  // If autoplay, auto-restart
  if (autoplayEnabled) {
    setTimeout(() => {
      startGame();
    }, 1000);
  }
}

function restartGame(skipConfirm) {
  if (!skipConfirm && !gameOver) {
    if (!confirm('Are you sure you want to restart the game? Your current score will be lost.')) return;
  }
  if (dropInterval) { clearInterval(dropInterval); dropInterval = null; }
  if (lockDelayTimer) { clearTimeout(lockDelayTimer); lockDelayTimer = null; }
  clearAutoplayTimers();
  startGame();
}

// ==================== AI AUTOPLAY ====================
function clearAutoplayTimers() {
  for (const t of autoplayTimers) clearTimeout(t);
  autoplayTimers = [];
}

function toggleAutoplay() {
  autoplayEnabled = !autoplayEnabled;
  const badge = document.getElementById('ai-badge');
  if (autoplayEnabled) {
    badge.textContent = 'AI ON';
    badge.className = 'ai-badge ai-on';
    if (gameActive && !gamePaused && !gameOver) {
      scheduleAutoplayMove();
    }
  } else {
    badge.textContent = 'AI OFF';
    badge.className = 'ai-badge ai-off';
    clearAutoplayTimers();
    lastAIScore = 'N/A';
  }
  updateStats();
}

function evaluateBoard(testBoard) {
  // Calculate holes
  let holes = 0;
  for (let x = 0; x < BOARD_WIDTH; x++) {
    let blockFound = false;
    for (let y = 0; y < BOARD_HEIGHT; y++) {
      if (testBoard[y][x] !== 0) blockFound = true;
      else if (blockFound) holes++;
    }
  }
  // Calculate column heights
  const heights = [];
  for (let x = 0; x < BOARD_WIDTH; x++) {
    let h = 0;
    for (let y = 0; y < BOARD_HEIGHT; y++) {
      if (testBoard[y][x] !== 0) { h = BOARD_HEIGHT - y; break; }
    }
    heights.push(h);
  }
  // Aggregate height
  const aggregateHeight = heights.reduce((a, b) => a + b, 0);
  // Bumpiness
  let bumpiness = 0;
  for (let i = 0; i < heights.length - 1; i++) {
    bumpiness += Math.abs(heights[i] - heights[i + 1]);
  }
  // Valley depth
  let valleyDepth = 0;
  for (let x = 0; x < BOARD_WIDTH; x++) {
    const left = (x > 0) ? heights[x - 1] : 0;
    const right = (x < BOARD_WIDTH - 1) ? heights[x + 1] : 0;
    const maxAdj = Math.max(left, right);
    if (heights[x] < maxAdj) {
      valleyDepth += maxAdj - heights[x];
    }
  }
  // Count cleared lines
  let linesCleared = 0;
  for (let y = 0; y < BOARD_HEIGHT; y++) {
    if (testBoard[y].every(c => c !== 0)) linesCleared++;
  }
  // Game over penalty
  let gameOverPenalty = 0;
  if (testBoard[0].some(c => c !== 0)) gameOverPenalty = -100000;

  return (linesCleared * aiWeights.lines * 100) +
         (holes * aiWeights.holes * 5) +
         (bumpiness * aiWeights.bumpiness) +
         (aggregateHeight * aiWeights.height) +
         (valleyDepth * aiWeights.valley) +
         gameOverPenalty;
}

function simulatePlacement(testBoard, shape, px, py) {
  // Drop piece to lowest position
  let dropY = py;
  while (true) {
    let collision = false;
    for (let y = 0; y < shape.length; y++) {
      for (let x = 0; x < shape[y].length; x++) {
        if (!shape[y][x]) continue;
        const bx = px + x;
        const by = dropY + 1 + y;
        if (by >= BOARD_HEIGHT) { collision = true; break; }
        if (by >= 0 && testBoard[by][bx] !== 0) { collision = true; break; }
      }
      if (collision) break;
    }
    if (collision) break;
    dropY++;
  }
  // Place piece
  const newBoard = testBoard.map(row => [...row]);
  for (let y = 0; y < shape.length; y++) {
    for (let x = 0; x < shape[y].length; x++) {
      if (shape[y][x]) {
        const by = dropY + y;
        const bx = px + x;
        if (by >= 0 && by < BOARD_HEIGHT) {
          newBoard[by][bx] = 1;
        }
      }
    }
  }
  return { board: newBoard, dropY };
}

function calculateBestMove(pieceType, testBoard) {
  let bestScore = -Infinity;
  let bestMove = null;
  let shape = getShape(pieceType);

  for (let r = 0; r < 4; r++) {
    const w = shape[0].length;
    for (let px = -1; px <= BOARD_WIDTH; px++) {
      // Bounds check
      let outOfBounds = false;
      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const bx = px + x;
            if (bx < 0 || bx >= BOARD_WIDTH) { outOfBounds = true; break; }
          }
        }
        if (outOfBounds) break;
      }
      if (outOfBounds) continue;

      const result = simulatePlacement(testBoard, shape, px, -shape.length);
      const evalScore = evaluateBoard(result.board);
      if (evalScore > bestScore) {
        bestScore = evalScore;
        bestMove = { rotations: r, targetX: px, type: pieceType };
      }
    }
    shape = rotateMatrix(shape);
  }
  return { move: bestMove, score: bestScore };
}

function scheduleAutoplayMove() {
  if (!autoplayEnabled || !gameActive || gamePaused || gameOver) return;
  clearAutoplayTimers();

  // Calculate best move for current piece
  const currentResult = calculateBestMove(currentType, board);
  let bestResult = currentResult;
  let useHold = false;

  // Consider hold piece
  if (canHold) {
    const holdPieceType = (holdType === -1) ? nextType : holdType;
    if (holdPieceType >= 0) {
      const holdResult = calculateBestMove(holdPieceType, board);
      if (holdResult.score > bestResult.score) {
        bestResult = holdResult;
        useHold = true;
      }
    }
  }

  lastAIScore = bestResult.score.toFixed(1);
  updateStats();

  if (!bestResult.move) return;

  executeAutoplayMove(bestResult.move, useHold);
}

function executeAutoplayMove(move, useHold) {
  const actions = [];

  if (useHold) {
    actions.push(() => holdPiece());
  }

  // Rotations
  for (let i = 0; i < move.rotations; i++) {
    actions.push(() => rotateCW());
  }

  // After rotations, move to target X
  actions.push(() => {
    // Calculate current needed movements after rotations
    const moveToX = () => {
      if (!gameActive || gamePaused || gameOver || !autoplayEnabled) return;
      if (currentX < move.targetX) {
        moveRight();
        const t = setTimeout(moveToX, autoplayDelay);
        autoplayTimers.push(t);
      } else if (currentX > move.targetX) {
        moveLeft();
        const t = setTimeout(moveToX, autoplayDelay);
        autoplayTimers.push(t);
      } else {
        // At target, hard drop
        const t = setTimeout(() => {
          if (!gameActive || gamePaused || gameOver || !autoplayEnabled) return;
          hardDrop();
        }, autoplayDelay);
        autoplayTimers.push(t);
      }
    };
    moveToX();
  });

  // Execute actions sequentially with delays
  let delay = autoplayDelay;
  for (let i = 0; i < actions.length - 1; i++) {
    const action = actions[i];
    const t = setTimeout(() => {
      if (!gameActive || gamePaused || gameOver || !autoplayEnabled) return;
      action();
    }, delay);
    autoplayTimers.push(t);
    delay += autoplayDelay;
  }
  // Last action (movement chain)
  const lastAction = actions[actions.length - 1];
  const t = setTimeout(() => {
    if (!gameActive || gamePaused || gameOver || !autoplayEnabled) return;
    lastAction();
  }, delay);
  autoplayTimers.push(t);
}

// ==================== INPUT HANDLING ====================
document.addEventListener('keydown', (e) => {
  const key = e.key.toLowerCase();

  // System keys always work
  if (key === 'a') {
    e.preventDefault();
    toggleAutoplay();
    return;
  }
  if (key === 'g') {
    e.preventDefault();
    if (gameActive) {
      ghostEnabled = !ghostEnabled;
      drawBoard();
    }
    return;
  }
  if (key === 'p' || key === 'escape') {
    e.preventDefault();
    if (gameActive) togglePause();
    return;
  }
  if (key === 'r') {
    e.preventDefault();
    if (gameOver) {
      restartGame(true);
    } else {
      restartGame(false);
    }
    return;
  }

  // Game controls - blocked when not active, paused, game over, or autoplay
  if (!gameActive || gamePaused || gameOver || autoplayEnabled) return;

  switch (e.key) {
    case 'ArrowLeft':
      e.preventDefault();
      moveLeft();
      break;
    case 'ArrowRight':
      e.preventDefault();
      moveRight();
      break;
    case 'ArrowDown':
      e.preventDefault();
      softDrop();
      break;
    case 'ArrowUp':
      e.preventDefault();
      rotateCW();
      break;
    case ' ':
      e.preventDefault();
      hardDrop();
      break;
    default:
      if (key === 'x') {
        e.preventDefault();
        rotateCW();
      } else if (key === 'c' || e.key === 'Shift') {
        e.preventDefault();
        holdPiece();
      }
  }
});

// ==================== UI EVENT HANDLERS ====================
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('resume-btn').addEventListener('click', togglePause);
document.getElementById('restart-btn').addEventListener('click', () => startGame());
document.getElementById('reset-hs-btn').addEventListener('click', () => {
  if (confirm('Are you sure you want to reset the high score? This action cannot be undone.')) {
    saveHighScore({ score: 0, lines: 0, level: 1 });
    displayHighScore();
  }
});

// AI Weight sliders
const sliderIds = [
  { id: 'w-lines', key: 'lines', valId: 'w-lines-val', decimals: 1 },
  { id: 'w-holes', key: 'holes', valId: 'w-holes-val', decimals: 1 },
  { id: 'w-bump', key: 'bumpiness', valId: 'w-bump-val', decimals: 1 },
  { id: 'w-height', key: 'height', valId: 'w-height-val', decimals: 2 },
  { id: 'w-valley', key: 'valley', valId: 'w-valley-val', decimals: 1 }
];

sliderIds.forEach(({ id, key, valId, decimals }) => {
  const slider = document.getElementById(id);
  const valDisplay = document.getElementById(valId);
  slider.addEventListener('input', () => {
    const val = parseFloat(slider.value);
    aiWeights[key] = val;
    valDisplay.textContent = val.toFixed(decimals);
    saveAIWeights();
  });
});

document.getElementById('reset-weights-btn').addEventListener('click', () => {
  aiWeights = { ...DEFAULT_AI_WEIGHTS };
  syncSlidersToWeights();
  saveAIWeights();
});

document.getElementById('autoplay-delay').addEventListener('change', (e) => {
  autoplayDelay = parseInt(e.target.value);
});

function syncSlidersToWeights() {
  sliderIds.forEach(({ id, key, valId, decimals }) => {
    document.getElementById(id).value = aiWeights[key];
    document.getElementById(valId).textContent = aiWeights[key].toFixed(decimals);
  });
}

// ==================== INITIALIZATION ====================
function init() {
  initBoard();
  initBoardDOM();
  initPreviewDOM(nextPreviewEl);
  initPreviewDOM(holdPreviewEl);
  loadAIWeights();
  syncSlidersToWeights();
  displayHighScore();
  updateStats();
  drawBoard();
}

init();
</script>
</body>
</html>
